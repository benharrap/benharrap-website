{
  "hash": "76a6de137f9d235f283520d5abd3957c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"tidyverse functions you might not know about\"\nformat: html\n---\n\n\n\n\n\nSometimes you ask for help and people provide you with solutions using functions you didn't know exist. That happened to me today and made me realise that I should look through the list of functions provided in the `tidyverse` packages I regularly use. So I did that and I discovered some cool functions that I should definitely be using!\n\nI've listed the functions here and some use cases I can see for them.\n\n## `dplyr`\n\nIf you want to check out the list of `dplyr` functions yourself, you can find them at [https://dplyr.tidyverse.org/reference/index.html](https://dplyr.tidyverse.org/reference/index.html){target=\"_blank\"}\n\n### Combining values from multiple columns row-wise (`c_across()`)\n\nScenario: You have set of variables you need to create a total score for, like the Kessler K-5.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\nset.seed(20250313)\nk5 <- tibble(\n  id = c(1,2,3,4),\n  q1 = round(runif(4,1,5),digits = 0),\n  q2 = round(runif(4,1,5),digits = 0),\n  q3 = round(runif(4,1,5),digits = 0),\n  q4 = round(runif(4,1,5),digits = 0),\n  q5 = round(runif(4,1,5),digits = 0)\n)\n```\n:::\n\n\n\n\n\n`c_across()` provides a neat way of doing this and is designed to work with data grouped using `rowwise()`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk5 |> \n  rowwise() |> \n  mutate(\n    k5_score = sum(c_across(q1:q5)),\n  ) |> \n  ungroup()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 7\n     id    q1    q2    q3    q4    q5 k5_score\n  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>    <dbl>\n1     1     5     5     3     3     3       19\n2     2     3     1     2     1     5       12\n3     3     1     2     3     1     2        9\n4     4     2     1     5     1     4       13\n```\n\n\n:::\n:::\n\n\n\n\n\nMy original approach would've used a combination of `rowSums()` and `pick()`:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk5 <- k5 |> \n  mutate(\n    k5_score = rowSums(pick(q1:q5))\n  )\nk5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 7\n     id    q1    q2    q3    q4    q5 k5_score\n  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>    <dbl>\n1     1     5     5     3     3     3       19\n2     2     3     1     2     1     5       12\n3     3     1     2     3     1     2        9\n4     4     2     1     5     1     4       13\n```\n\n\n:::\n:::\n\n\n\n\n\nThe advantage of my original approach is you don't need to specify `rowwise()` and `ungroup()`, but this only works for sums and means because base only provides `rowSums` and `rowMeans`. If you want to do any other operations, `c_across()` is your friend!\n\n### Set values to missing under a condition (`na_if()`)\n\nI would normally use `case_when()` to set observations to missing when they meet particular conditions, but `na_if()` seems like a more direct way of doing that:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk5 <- k5 |> \n  mutate(\n    k5_score = na_if(k5_score, 13)\n  )\nk5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 7\n     id    q1    q2    q3    q4    q5 k5_score\n  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>    <dbl>\n1     1     5     5     3     3     3       19\n2     2     3     1     2     1     5       12\n3     3     1     2     3     1     2        9\n4     4     2     1     5     1     4       NA\n```\n\n\n:::\n:::\n\n\n\n\n\n### `ifelse` but `tidyverse` style (`if_else()`)\n\nI would normally have used `case_when()` in this case too, as I find it easier read what's happening in each condition, but occasionally I find myself using `ifelse` for convenience when I only need to use one condition.\n\n`if_else()` just seems like a better version of `ifelse()`. The main appeal is the inclusion of the `missing` argument, which lets you specify what you want missing values to be coded as:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk5 |> \n  mutate(\n    k5_category = if_else(k5_score < 12, \"low\",\"high\", missing = \"missing\")\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 8\n     id    q1    q2    q3    q4    q5 k5_score k5_category\n  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>    <dbl> <chr>      \n1     1     5     5     3     3     3       19 high       \n2     2     3     1     2     1     5       12 high       \n3     3     1     2     3     1     2        9 low        \n4     4     2     1     5     1     4       NA missing    \n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}