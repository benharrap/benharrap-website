{
  "hash": "fe07b3bcc7ba0f0d0013bc5327c6d914",
  "result": {
    "engine": "knitr",
    "markdown": "---\nformat: html\ntitle: \"tidyverse functions you might not know about\"\nauthor: Ben Harrap\ndate: 2025-05-23\ntoc: true\ncategories: \n  - R\n  - programming\n  - data\n---\n\n\n\nSometimes you ask for help and people provide you with solutions using functions you didn't know exist. That happened to me today and made me realise that I should look through the list of functions provided in the `tidyverse` packages I regularly use. So I did that and I discovered some cool functions that I should definitely be using!\n\nI've listed some handy functions here and some use cases I've had for them.\n\n## `dplyr`\n\nIf you want to check out the list of `dplyr` functions yourself, you can find them at [https://dplyr.tidyverse.org/reference/index.html](https://dplyr.tidyverse.org/reference/index.html){target=\"_blank\"}\n\n### Combining values from multiple columns row-wise (`c_across()`)\n\nScenario: You have set of variables you need to create a total score for, like the Kessler K-5.\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 6\n     id    q1    q2    q3    q4    q5\n  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1     1     5     5     3     3     3\n2     2     3     1     2     1     5\n3     3     1     2     3     1     2\n4     4     2     1     5     1     4\n```\n\n\n:::\n:::\n\n\n\n`c_across()` provides a neat way of doing this and is designed to work with data grouped using `rowwise()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk5 |> \n  rowwise() |> \n  mutate(\n    k5_score = sum(c_across(q1:q5)),\n  ) |> \n  ungroup()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 7\n     id    q1    q2    q3    q4    q5 k5_score\n  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>    <dbl>\n1     1     5     5     3     3     3       19\n2     2     3     1     2     1     5       12\n3     3     1     2     3     1     2        9\n4     4     2     1     5     1     4       13\n```\n\n\n:::\n:::\n\n\n\nMy original approach would've used a combination of `rowSums()` and `pick()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk5 <- k5 |> \n  mutate(\n    k5_score = rowSums(pick(q1:q5))\n  )\nk5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 7\n     id    q1    q2    q3    q4    q5 k5_score\n  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>    <dbl>\n1     1     5     5     3     3     3       19\n2     2     3     1     2     1     5       12\n3     3     1     2     3     1     2        9\n4     4     2     1     5     1     4       13\n```\n\n\n:::\n:::\n\n\n\nThe advantage of my original approach is you don't need to specify `rowwise()` and `ungroup()`, but this only works for sums and means because base only provides `rowSums` and `rowMeans`. If you want to do any other operations, `c_across()` is your friend!\n\n### Set values to missing under a condition (`na_if()`)\n\nI would normally use `case_when()` to set observations to missing when they meet particular conditions, but `na_if()` seems like a more direct way of doing that:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk5 <- k5 |> \n  mutate(\n    k5_score = na_if(k5_score, 13)\n  )\nk5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 7\n     id    q1    q2    q3    q4    q5 k5_score\n  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>    <dbl>\n1     1     5     5     3     3     3       19\n2     2     3     1     2     1     5       12\n3     3     1     2     3     1     2        9\n4     4     2     1     5     1     4       NA\n```\n\n\n:::\n:::\n\n\n\n### `ifelse` but `tidyverse` style (`if_else()`)\n\nI would normally have used `case_when()` in this case too, as I find it easier read what's happening in each condition, but occasionally I find myself using `ifelse` for convenience when I only need to use one condition.\n\n`if_else()` just seems like a better version of `ifelse()`. The main appeal is the inclusion of the `missing` argument, which lets you specify what you want missing values to be coded as:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk5 |> \n  mutate(\n    k5_category = if_else(k5_score < 12, \"low\",\"high\", missing = \"missing\")\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 8\n     id    q1    q2    q3    q4    q5 k5_score k5_category\n  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>    <dbl> <chr>      \n1     1     5     5     3     3     3       19 high       \n2     2     3     1     2     1     5       12 high       \n3     3     1     2     3     1     2        9 low        \n4     4     2     1     5     1     4       NA missing    \n```\n\n\n:::\n:::\n\n\n\n### Using another dataset up update rows (`rows_update()`)\n\nThis was a great recommendation by someone who helped me solve a problem efficiently. I had one dataset consisting of uncleaned responses to a paper questionnaire, which had been digitsed using OCR. I had a secondary dataset where the original paper questionnaire had been audited when the OCR seemed to have done a poor job. \n\nSticking with the K-5 data, imagine we have the audited data as follows:\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 4\n     id variable original audited\n  <dbl> <chr>       <dbl>   <dbl>\n1     3 q1              2       1\n2     3 q2              4       5\n```\n\n\n:::\n:::\n\n\n\nAll I had to do was use `pivot_longer()` to put the uncleaned data into long format and then use `rows_update()` to find and replace the corresponding values, then `pivot_wider()` back into the original format.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk5 |> \n  pivot_longer(\n    !id,\n    names_to = \"variable\",\n    values_to = \"response\"\n    ) |>\n  rows_update(\n    audit |> \n      rename(response = audited) |> \n      select(id, variable, response),\n    by = c(\"id\",\"variable\")\n  ) |> \n  pivot_wider(\n    names_from = \"variable\",\n    values_from = \"response\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 7\n     id    q1    q2    q3    q4    q5 k5_score\n  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>    <dbl>\n1     1     5     5     3     3     3       19\n2     2     3     1     2     1     5       12\n3     3     1     5     3     1     2        9\n4     4     2     1     5     1     4       NA\n```\n\n\n:::\n:::\n\n\n\nNote that inside of `rows_update()` I take `audit`, rename the column with the correct values to match the column name in the `data`, then keep only the columns used to identify the unique rows (`id` and `variable`) and the value used for updating (`response`).\n\nThere's a whole suite of row-specific functions (see [here](https://dplyr.tidyverse.org/reference/rows.html)), but I have found `rows_update()` being especially helpful.\n\n### Adding rows to a dataset `bind_rows()`\n\nI feel like everyone probably knows about this, but I wanted to quickly mention that I recently discovered I was using it inefficiently! `bind_rows()` accepts multiple things to be bound, meaning you can write:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf1 |> bind_rows(df2, df3, df4)\n```\n:::\n\n\n\nInstead of what I was previously doing:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf1 |> \n  bind_rows(df2) |> \n  bind_rows(df3) |> \n  bind_rows(df4)\n```\n:::\n\n\n\n## `tibble`\n\nYou can find the `tibble` reference list here [https://tibble.tidyverse.org/reference/index.html](https://tibble.tidyverse.org/reference/index.html)\n\n### Adding rows in specific locations (`add_row()`)\n\nThe use-case I had for this was actually solved by just using `gtsummary`, but before I discovered that package I was making summary tables by hand. I'd do this by combining the output from `tabyl()` and `summarise()` into one data frame. For example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary <- k5 |>\n  summarise(\n    n = n(),\n    mean = mean(q1),\n    sd = sd(q1),\n    min = min(q1),\n    max = max(q1)\n  ) |>\n  pivot_longer(everything())\n\nsummary\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 2\n  name  value\n  <chr> <dbl>\n1 n      4   \n2 mean   2.75\n3 sd     1.71\n4 min    1   \n5 max    5   \n```\n\n\n:::\n:::\n\n\n\nBut the number of participants is different to summaries of responses to Q1, so I want to add a row to make this clear. This is easily done by using the `.before = ` argument: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary |> \n  add_row(\n    name = \"Q1 responses\",\n    .before = 2\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 2\n  name         value\n  <chr>        <dbl>\n1 n             4   \n2 Q1 responses NA   \n3 mean          2.75\n4 sd            1.71\n5 min           1   \n6 max           5   \n```\n\n\n:::\n:::\n\n\n\n### Converting lists to tibbles (`enframe()`)\n\nI've been doing a lot of work with APIs and getting data returned as JSON, which the `httr2` package helpfully converts into a more usable format in R. Unfortunately, what I get tends to be a lot of nested lists that I need to combine together into a rectangular format.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list <- c(\"Victoria\",\"Western Australia\",\"Tasmania\")\n\nmy_list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Victoria\"          \"Western Australia\" \"Tasmania\"         \n```\n\n\n:::\n:::\n\n\n\nEnter `enframe()`. It works with vectors and converts them into a tibble with two columns. Very simple, very useful.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nenframe(my_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n   name value            \n  <int> <chr>            \n1     1 Victoria         \n2     2 Western Australia\n3     3 Tasmania         \n```\n\n\n:::\n:::\n\n\n\n## `tidyr`\n\nSee the `tidyr` reference list here [https://tidyr.tidyverse.org/reference/index.html](https://tidyr.tidyverse.org/reference/index.html)\n\n### Getting values out of list columns (`unnest()`)\n\nBuilding on the previous example, you might end up with a column that contains lists, but you want those values as columns (or rows).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list <- tibble(\n  state = list(tibble(\"Victoria\",\"Western Australia\",\"Tasmania\")),\n  territory = list(tibble(\"Australian Capital Territory\",\"Northern Territory\"))\n    )\n\nmy_list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  state            territory       \n  <list>           <list>          \n1 <tibble [1 × 3]> <tibble [1 × 2]>\n```\n\n\n:::\n:::\n\n\n\nThese lists can be extracted using `unnest`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunnest(my_list, col = c(state, territory))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 5\n  `\"Victoria\"` `\"Western Australia\"` `\"Tasmania\"` \"Australian Capital Territor…¹\n  <chr>        <chr>                 <chr>        <chr>                         \n1 Victoria     Western Australia     Tasmania     Australian Capital Territory  \n# ℹ abbreviated name: ¹​`\"Australian Capital Territory\"`\n# ℹ 1 more variable: `\"Northern Territory\"` <chr>\n```\n\n\n:::\n:::\n\n\n\nThere's also `unnest_longer()` and `unnest_wider()`, depending on the shape you.\n\n### Propagating non-missing values row-wise (`fill()`)\n\nThis has been such a useful function in so many situations for me, yet somehow I frequently forget about it!\n\nMy most recent use-case was creating a data dictionary based on metadata output from REDCap. In the questionnaire, section headers are used to paginate the different sections, but in the metadata the header is attached to a single variable:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndictionary <- tibble(\n  variable = c(\"name\",\"dob\",\"q1\",\"q2\",\"q3\",\"q4\",\"q5\"),\n  header = c(\"About you\",NA,\"Psychological distress\",NA,NA,NA,NA)\n)\n\ndictionary\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 2\n  variable header                \n  <chr>    <chr>                 \n1 name     About you             \n2 dob      <NA>                  \n3 q1       Psychological distress\n4 q2       <NA>                  \n5 q3       <NA>                  \n6 q4       <NA>                  \n7 q5       <NA>                  \n```\n\n\n:::\n:::\n\n\n\nWhen creating the data dictionary, I want the header to be present for every variable as it can be useful to identify or analyse data by section:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndictionary |> \n  fill(header, .direction = \"down\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 2\n  variable header                \n  <chr>    <chr>                 \n1 name     About you             \n2 dob      About you             \n3 q1       Psychological distress\n4 q2       Psychological distress\n5 q3       Psychological distress\n6 q4       Psychological distress\n7 q5       Psychological distress\n```\n\n\n:::\n:::\n\n\n\nThe `.direction` argument accepts \"down\", \"up\", \"downup\", and \"updown\", meaning you can fill in multiple directions. This is especially powerful when you combine it with `group_by()`, allowing you to fill without worrying about propagating into the wrong group.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}