{
  "hash": "cab829cb0e26901d575f2c930379bc41",
  "result": {
    "engine": "knitr",
    "markdown": "---\nformat: html\ntitle: \"Joining strings with missing data together in R\"\nauthor: Ben Harrap\ndate: 2025-09-24\ntoc: false\ncategories: \n  - R\n  - programming\n  - strings\n---\n\nJoining multiple string columns together in R isn't a particularly tricky thing to do, but I have found it unreasonably annoying trying to deal with missing data in some of the columns. For example, let's say we've got the following address data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4          ✔ readr     2.1.5     \n✔ forcats   1.0.0          ✔ stringr   1.5.1     \n✔ ggplot2   3.5.2          ✔ tibble    3.3.0     \n✔ lubridate 1.9.4          ✔ tidyr     1.3.1     \n✔ purrr     1.1.0.9000     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\naddresses <- tibble(\n  unit = c(\"Shop 4\",\"Unit 185\", NA, NA),\n  street = c(\"2 Frencham Pl\",\"20 Allara St\",\"1 McCoy Cct\",\"130 Garran Rd Acton ACT 2601\"),\n  suburb = c(\"Downer\",\"Canberra\",\"Acton\", NA),\n  postcode = c(\"2602\",\"2601\",\"2601\", NA)\n)\n```\n:::\n\n\nThe first two have a value for each element, while the third address doesn't have a `unit`, and the fourth for some reason has all the elements in `street`. What I want to do is combine all of these address elements into a single string and ignore missing values. Let's review the ways we can go about this.\n\n## `tidyr::unite()`\n\nI'll cut to the chase – `tidyr::unite()` is perfect for this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\naddresses |>\n  bind_cols(\n    unite(\n      data = addresses,\n      col = \"address\",\n      sep = \" \",\n      na.rm = TRUE\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 5\n  unit     street                       suburb   postcode address               \n  <chr>    <chr>                        <chr>    <chr>    <chr>                 \n1 Shop 4   2 Frencham Pl                Downer   2602     Shop 4 2 Frencham Pl …\n2 Unit 185 20 Allara St                 Canberra 2601     Unit 185 20 Allara St…\n3 <NA>     1 McCoy Cct                  Acton    2601     1 McCoy Cct Acton 2601\n4 <NA>     130 Garran Rd Acton ACT 2601 <NA>     <NA>     130 Garran Rd Acton A…\n```\n\n\n:::\n:::\n\n\nI only recently learned about `unite()` (thanks Stephen!) and was surprised to find it in `tidyr` and not in `stringr`. Anyway, it's perfect!\n\n## `base::paste()`\n\nWe could use `paste()`, except that it includes `NA` as the letters NA in the output, which is not what I want.\n\n\n::: {.cell}\n\n```{.r .cell-code}\naddresses |> \n  mutate(\n    address = paste(\n      unit, street, suburb, postcode,\n      sep = \" \"\n      )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 5\n  unit     street                       suburb   postcode address               \n  <chr>    <chr>                        <chr>    <chr>    <chr>                 \n1 Shop 4   2 Frencham Pl                Downer   2602     Shop 4 2 Frencham Pl …\n2 Unit 185 20 Allara St                 Canberra 2601     Unit 185 20 Allara St…\n3 <NA>     1 McCoy Cct                  Acton    2601     NA 1 McCoy Cct Acton …\n4 <NA>     130 Garran Rd Acton ACT 2601 <NA>     <NA>     NA 130 Garran Rd Acto…\n```\n\n\n:::\n:::\n\n\nWe could do some cleaning to overcome this issue:\n\n\n::: {.cell}\n\n```{.r .cell-code}\naddresses |>\n  replace_na(\n    replace = list(unit = \"\", suburb = \"\", postcode = \"\")\n  ) |>\n  mutate(\n    address = paste(\n      unit, street, suburb, postcode,\n      sep = \" \"\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 5\n  unit       street                       suburb     postcode address           \n  <chr>      <chr>                        <chr>      <chr>    <chr>             \n1 \"Shop 4\"   2 Frencham Pl                \"Downer\"   \"2602\"   \"Shop 4 2 Frencha…\n2 \"Unit 185\" 20 Allara St                 \"Canberra\" \"2601\"   \"Unit 185 20 Alla…\n3 \"\"         1 McCoy Cct                  \"Acton\"    \"2601\"   \" 1 McCoy Cct Act…\n4 \"\"         130 Garran Rd Acton ACT 2601 \"\"         \"\"       \" 130 Garran Rd A…\n```\n\n\n:::\n:::\n\n\nBut the empty strings are now causing excessive separators to be included. We can fix this with `str_trim()` and `str_squish()`, but it's getting silly at this point. Just use `unite()`!\n\n\n::: {.cell}\n\n```{.r .cell-code}\naddresses |>\n  replace_na(\n    replace = list(unit = \"\", suburb = \"\", postcode = \"\")\n  ) |>\n  mutate(\n    address = str_trim(\n      paste(\n        unit, street, suburb, postcode,\n        sep = \" \"\n      )\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 5\n  unit       street                       suburb     postcode address           \n  <chr>      <chr>                        <chr>      <chr>    <chr>             \n1 \"Shop 4\"   2 Frencham Pl                \"Downer\"   \"2602\"   Shop 4 2 Frencham…\n2 \"Unit 185\" 20 Allara St                 \"Canberra\" \"2601\"   Unit 185 20 Allar…\n3 \"\"         1 McCoy Cct                  \"Acton\"    \"2601\"   1 McCoy Cct Acton…\n4 \"\"         130 Garran Rd Acton ACT 2601 \"\"         \"\"       130 Garran Rd Act…\n```\n\n\n:::\n:::\n\n\n## `base::sprintf()`\n\nAnother base option is to use `sprintf()`, which seems like we'd still need to do some extra work to handle the `NA`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\naddresses |> \n  mutate(\n    address = sprintf(\n      \"%s %s %s %s\",\n      unit, street, suburb, postcode\n      )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 5\n  unit     street                       suburb   postcode address               \n  <chr>    <chr>                        <chr>    <chr>    <chr>                 \n1 Shop 4   2 Frencham Pl                Downer   2602     Shop 4 2 Frencham Pl …\n2 Unit 185 20 Allara St                 Canberra 2601     Unit 185 20 Allara St…\n3 <NA>     1 McCoy Cct                  Acton    2601     NA 1 McCoy Cct Acton …\n4 <NA>     130 Garran Rd Acton ACT 2601 <NA>     <NA>     NA 130 Garran Rd Acto…\n```\n\n\n:::\n:::\n\n\n## `stringr::str_c()`\n\nWe could use `str_c()` but we'll have the same issues as we did with `paste`. Notice though that `str_c` returns `NA` if any of the input strings are `NA`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\naddresses |> \n  mutate(\n    address = str_c(\n      unit, street, suburb, postcode,\n      sep = \" \"\n      )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 5\n  unit     street                       suburb   postcode address               \n  <chr>    <chr>                        <chr>    <chr>    <chr>                 \n1 Shop 4   2 Frencham Pl                Downer   2602     Shop 4 2 Frencham Pl …\n2 Unit 185 20 Allara St                 Canberra 2601     Unit 185 20 Allara St…\n3 <NA>     1 McCoy Cct                  Acton    2601     <NA>                  \n4 <NA>     130 Garran Rd Acton ACT 2601 <NA>     <NA>     <NA>                  \n```\n\n\n:::\n:::\n\n\n## `stringr::str_flatten()`\n\nInterestingly, we can achieve the same result as `unite()` if we perform `str_flatten()` on a row-wise basis. I doubt this is a good idea though, as row-wise stuff tends to get very expensive, very quickly.\n\n\n::: {.cell}\n\n```{.r .cell-code}\naddresses |> \n  rowwise() |> \n  mutate(\n    address = str_flatten(\n      c(unit, street, suburb, postcode),\n      collapse = \" \",\n      na.rm = TRUE\n      )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 5\n# Rowwise: \n  unit     street                       suburb   postcode address               \n  <chr>    <chr>                        <chr>    <chr>    <chr>                 \n1 Shop 4   2 Frencham Pl                Downer   2602     Shop 4 2 Frencham Pl …\n2 Unit 185 20 Allara St                 Canberra 2601     Unit 185 20 Allara St…\n3 <NA>     1 McCoy Cct                  Acton    2601     1 McCoy Cct Acton 2601\n4 <NA>     130 Garran Rd Acton ACT 2601 <NA>     <NA>     130 Garran Rd Acton A…\n```\n\n\n:::\n:::\n\n\n## `glue::glue()`\n\n`glue` is another option and arguably works better than `paste` or `str_c` because of the `.na` option letting us handle the `NA` within the function itself.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(glue)\naddresses |> \n  mutate(\n    address = glue(\n      \"{unit}\",\"{street}\",\"{suburb}\",\"{postcode}\",\n      .na = \"\",\n      .sep = \" \"\n      )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 5\n  unit     street                       suburb   postcode address               \n  <chr>    <chr>                        <chr>    <chr>    <glue>                \n1 Shop 4   2 Frencham Pl                Downer   2602     Shop 4 2 Frencham Pl …\n2 Unit 185 20 Allara St                 Canberra 2601     Unit 185 20 Allara St…\n3 <NA>     1 McCoy Cct                  Acton    2601      1 McCoy Cct Acton 26…\n4 <NA>     130 Garran Rd Acton ACT 2601 <NA>     <NA>      130 Garran Rd Acton …\n```\n\n\n:::\n:::\n\n\nAgain though, we'd need to trim the leading whitespace created.\n\n## Summary\n\nUse `unite()` when you've got missing data that you don't want propagated into your new string column!",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}